"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const _require = require('create-jest-runner'),
      pass = _require.pass,
      fail = _require.fail,
      skip = _require.skip;

const _require2 = require('eslint'),
      CLIEngine = _require2.CLIEngine;

const getESLintOptions = require('../utils/getESLintOptions');

const getComputedFixValue = ({
  fix,
  quiet,
  fixDryRun
}) => {
  if (fix || fixDryRun) {
    return quiet ? ({
      severity
    }) => severity === 2 : true;
  }

  return undefined;
};

let cachedValues;

const getCachedValues = (config, extraOptions) => {
  if (!cachedValues) {
    const _getESLintOptions = getESLintOptions(config),
          baseCliOptions = _getESLintOptions.cliOptions;

    const cliOptions = _objectSpread({}, baseCliOptions, {
      fix: getComputedFixValue(baseCliOptions)
    }, extraOptions);

    const cli = new CLIEngine(cliOptions);
    const formatter = cli.getFormatter(cliOptions.format);
    cachedValues = {
      cli,
      formatter,
      cliOptions
    };
  }

  return cachedValues;
};

const runESLint = ({
  testPath,
  config,
  extraOptions
}) => {
  const start = Date.now();

  if (config.setupTestFrameworkScriptFile) {
    // eslint-disable-next-line import/no-dynamic-require,global-require
    require(config.setupTestFrameworkScriptFile);
  }

  const _getCachedValues = getCachedValues(config, extraOptions),
        cli = _getCachedValues.cli,
        formatter = _getCachedValues.formatter,
        cliOptions = _getCachedValues.cliOptions;

  if (cli.isPathIgnored(testPath)) {
    const end = Date.now();
    return skip({
      start,
      end,
      test: {
        path: testPath,
        title: 'ESLint'
      }
    });
  }

  const report = cli.executeOnFiles([testPath]);

  if (cliOptions.fix && !cliOptions.fixDryRun) {
    CLIEngine.outputFixes(report);
  }

  const end = Date.now();
  const message = formatter(cliOptions.quiet ? CLIEngine.getErrorResults(report.results) : report.results);

  if (report.errorCount > 0) {
    return fail({
      start,
      end,
      test: {
        path: testPath,
        title: 'ESLint',
        errorMessage: message
      }
    });
  }

  const tooManyWarnings = cliOptions.maxWarnings >= 0 && report.warningCount > cliOptions.maxWarnings;

  if (tooManyWarnings) {
    return fail({
      start,
      end,
      test: {
        path: testPath,
        title: 'ESLint',
        errorMessage: `${message}\nESLint found too many warnings (maximum: ${cliOptions.maxWarnings}).`
      }
    });
  }

  const result = pass({
    start,
    end,
    test: {
      path: testPath,
      title: 'ESLint'
    }
  });

  if (!cliOptions.quiet && report.warningCount > 0) {
    result.console = [{
      message,
      origin: '',
      type: 'warn'
    }];
  }

  return result;
};

module.exports = runESLint;